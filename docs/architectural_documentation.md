# Design Document
###  Общее описание системы
1. **Название**: Интерпретатор командной строки (CLI)
2. **Цель системы**: Предоставление функциональности для выполнения команд/пайплайнов, управления переменными окружения и поддержки встроенных команд..
3. **Основные функции**:
   * Выполнение команд (встроенных и внешних).
   * Управление переменными окружения.
   * Поддержка пайплайнов.

### Стейкхолдеры
1. **Разработчики**
    * Важно, чтобы система была легко расширяемой, поддерживаемой и легко тестируемой.
    * Все компоненты системы должны быть разделены и иметь минимальное число связей. Должна быть возможность добавлять новые команды. Легкость тестирования.
2. **Пользователи**
   * Быстрота выполнения команд и пайплайнов, понятный вывод ошибок, удобство использования, корректная работа
   * Нужна подробная документация для использования CLI

### Архитектура системы
#### Точки зрения
1. **Функциональность**
    * Интерес стейкхолдеров: нужна разработчикам, чтобы понимать как компоненты системы взаимодействуют друг с другом для разработки системы и ее тестирования.
    * Описание:
         * CLI передает их в Parser для обработки и разбиения на команды.
         * Parser создаёт объекты Command и передаёт их в Pipeline.
         * Pipeline управляет выполнением команд через Executor.
         * Executor выполняет команды и возвращает результат.
2. **Хранение данных**
    * Интерес стейкхолдеров: разработчикам важно понимать как устроено хранение данных, которые вводит пользователь
    * Описание:
         * Команды хранятся в объектах Command, которые содержат имя команды и аргументы.
         * Переменные окружения хранятся в компоненте Environment.
3. **Разработка**
    * Интерес стейкхолдеров: разработчикам важно понимать, как можно расширить приложение и добавлять новые команды.
    * Описание:
         * Для добавления новой команды необходимо:
           * Добавить обработчик в Executor.
           * Добавить значение в enum внутри Command.
           * Реализовать проверку аргументов в Command.
4. **Описание использования и вывод ошибок**
   * Интерес стейкхолдеров: 
     * пользователям важно понимать, как взаимодействовать с системой и получать информацию об ошибках.
     * разработчикам нужно понимать, какую информацию выводить пользователю
   * Описание:
     * Команды вводятся в терминале.
     * Результат выполнения команды выводится в терминал.
     * В случае ошибки выводится понятное сообщение и ненулевой код возврата.

#### Архитектурные решения
1. **Разделение ответственности**: Каждый компонент (Command, Environment, CLI, Parser, Pipeline, Executor) отвечает за одну задачу.
2. **Использование Pipeline для управления выполнением команд**. Pipeline поддерживает выполнение как одиночных команд, так и пайплайнов. Для пайплайнов используется пул потоков.
3. **Расширяемость системы**. Для добавления новой команды достаточно добавить соответствующий обработчик в Executor.execute(Command), поскольку поведения остальных частей не завязано на конкретную команду, а является общим для всех.
Добавить в list/enum внутри Command новое значение.


#### Взаимодействие компонентов
* Пользователь вводит команду или пайплайн в терминале.
* CLI получает входную строку.
* CLI передает входную строку в Parser для дальнейшей обработки.
* Parser получает строку от CLI.
* Parser разбивает строку на токены с учетом кавычек и подстановок переменных.
* Parser обрабатывает подстановки переменных
  * Если в строке встречаются переменные, Parser запрашивает их значения у Environment.
  * Environment возвращает значение переменной.
  * Parser заменяет переменную на её значение в токенах.
* Parser удаляет кавычки и экранирует специальные символы:
  * Если токены содержат кавычки (одинарные или двойные), Parser удаляет их.
  * Специальные символы внутри двойных кавычек экранируются.
* Parser разбивает токены на команды:
  * Если в строке есть символ |, Parser разделяет токены на несколько команд.
* Для каждой команды Parser создает объект Command, который содержит:
  * Имя команды.
  * Аргументы команды (например, /home/user или user).
* Parser возвращает список объектов Command в CLI.
* CLI получает от Parser список команд (List[Command]).
* CLI передает этот список в Pipeline для выполнения.
* Pipeline получает список команд от CLI.
* Pipeline определяет, является ли список команд пайплайном (несколько команд, соединенных через |).
  * Если команда одна:
    * Pipeline передает команду в Executor для выполнения.
  * Если команды объединены в пайплайн:
    * Pipeline определяет потоки ввода и вывода для каждой команды.
    * Создает пул потоков для параллельного выполнения команд.
    * Передает каждую команду в Executor для выполнения.
  * Ожидает завершения всех потоков.
* Executor выполняет команды:
  * Executor получает команду от Pipeline.
  * Executor проверяет, является ли команда встроенной (isBuiltin).
    * Если команда встроенная (например, exit), выполняет ее и возвращает результат.
  * Если команда внешняя:
    * Создает новый процесс через ProcessBuilder.
    * Выполняет команду.
  * Возвращает код возврата выполнения команды в Pipeline.
* Pipeline возвращает результат в CLI:
  * Pipeline получает результат выполнения команды от Executor.
  * Pipeline возвращает результат выполнения (код возврата и вывод) в CLI.
* CLI обновляет переменные окружения и выводит результат:
  * CLI получает результат выполнения от Pipeline.
  * CLI обновляет переменную окружения, отвечающую за код возврата (например, переменную ?).
  * CLI выводит результат выполнения команды пользователю.
#### Основные компоненты системы
1. **CLI**\
Основной процесс, который управляет жизненным циклом интерпретатора.
   * Управляет жизненным циклом интерпретатора.
   * Инициализирует систему (создает объект Environment).
   * Обрабатывает входную строку.
   * Передает строку в Parser.
   * Передает результат работы Parser в Pipeline.
   * Обновляет переменную окружения, отвечающую за код возврата.
2. **Parser** \
Компонент для разбора входной строки.
   * Разбирает входную строку на токены.
   * Обрабатывает подстановку переменных окружения.
   * Проверяет синтаксис команд.
   * Создает объекты Command для каждой команды.
   * Возвращает список команд (List[Command]).
3. **Environment**\
Компонент для работы с переменными.
   * Хранит переменные окружения.
   * Предоставляет методы для добавления, изменения и получения переменных.
4. **Pipeline**\
Компонент для управления выполнением цепочки команд. Отвечает за:
   * Управляет выполнением цепочки команд.
   * Определяет потоки ввода и вывода для каждой команды.
   * Создает пул потоков для выполнения команд.
   * Ожидает завершения всех потоков.
5. **Executor**\
Компонент для выполнения команд. Отвечает за:
   * Выполняет команды.
   * Проверяет, является ли команда встроенной.
   * Создает новые процессы для внешних команд.
   * Возвращает код возврата выполнения команды.
6. **Command**\
Компонент, представляющий команду. Отвечает за:
   * Представляет команду.
   * Хранит имя команды, аргументы и стандартные потоки ввода/вывода.
   * Предоставляет методы для проверки аргументов и выполнения команды.

![](images/class_diagram.png)

![](images/component_diagram.png)

### Разбор аргументов командной строки

Для реализации команды `grep` мы рассмотрели следующие библиотеки и фреймворки для разбора параметров командной строки:

### Apache Commons CLI

**Преимущества**:

1. Низкий порог входа благодаря подробной документации и множеству примеров
2. Поддержка как коротких, так и длинных флагов
3. Обработка позиционных аргументов
4. Встроенная поддержка сообщений справки

**Недостатки**:

1. Отсутствие поддержки аннотаций, что приводит к большему количеству шаблонного кода
2. Нет поддержки подкоманд
3. Все значения возвращаются как строки, требуется ручной парсинг
4. Ручная валидация входных данных

**Лучше всего подходит для**: Небольших CLI-приложений, где важна простота

### JCommander

**Преимущества**:

1. Конфигурация на основе аннотаций
2. Поддержка вложенных команд и подкоманд
3. Встроенная валидация
4. Возможность указания значений по умолчанию
5. Хорошая документация и активное сообщество

**Недостатки**:

1. Отсутствие встроенной поддержки цветного вывода
2. Нет автодополнения команд
3. Требует Java 8 или выше

**Лучше всего подходит для**: CLI-приложений средней сложности, которым нужно больше возможностей, чем Apache Commons CLI

### Picocli

**Преимущества**:

1. Полноценная поддержка автодополнения
2. Встроенный цветной вывод
3. Поддержка сообщений справки в виде таблиц
4. Валидация на основе аннотаций
5. Автоматическое преобразование типов
6. Отличная поддержка подкоманд

**Недостатки**:

1. Более сложная настройка
2. Больший размер зависимостей

**Лучше всего подходит для**: Профессиональных CLI-приложений с богатым функционалом

### Airline

**Преимущества**:

1. Интегрированная система валидации
2. Поддержка неограниченной вложенности команд
3. Гибкое определение команд (аннотации или программно)

**Недостатки**:

1. Нет встроенного автодополнения
2. Отсутствие поддержки цветного вывода
3. Избыточная сложность для небольших утилит
4. Меньшая поддержка сообщества

**Лучше всего подходит для**: Сложных CLI-приложений с глубокой иерархией команд

### Наше решение

Мы выбрали **JCommander**, потому что:

- Он предоставляет больше возможностей, чем Apache Commons CLI
- Поддержка аннотаций повышает эффективность разработки
- Дополнительные возможности Picocli и Airline были бы избыточны для нашего проекта