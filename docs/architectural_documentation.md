# Design Document
##  1. Общее описание системы
### 1.1 Название системы
Интерпретатор командной строки (CLI)

### 1.2 Цель системы
Предоставление функциональности для выполнения команд/пайплайнов, управления переменными окружения и поддержки встроенных команд.

### 1.3 Основные функциональные возможности
* Выполнение команд (встроенных и внешних).
* Управление переменными окружения.
* Поддержка пайплайнов.

## 2. Стейкхолдеры и их интересы
| Роль    | Ключевые интересы                                                                                                              | Архитектурные решения                                                                              |
|---------|--------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------|
| Разработчики | Модульность, расширяемость, тестируемость                                                                                      | Чёткое разделение компонентов (Parser, Pipeline, Executor)                                         |
|         | Простота добавления новых команд, минимальное число связей                                                                     | Шаблон Command с enum builtin-команд                                                               |
| Пользователи | Быстрое выполнение команд и пайплайнов| POSIX-совместимый синтаксис                                                                        |
|| Понятный вывод ошибок и удобный синтаксис|Стандартные коды возврата|
|| Подробная документация| Примеры использования в документации|

## 3. Точки зрения (Viewpoints)

| Viewpoint            | Стейкхолдеры | Интересы                                                                                      | Модели/Артефакты            |
|----------------------|-------------|-----------------------------------------------------------------------------------------------|-----------------------------|
| Viewpoint            | Стейкхолдеры | Интересы                                                                                      | Модели/Артефакты            |
| Функциональное поведение | Разработчики | Как компоненты системы взаимодействуют друг с другом для разработки системы и ее тестирования | Диаграмма компонентов       |
| Хранение данных      | Разработчики | Структура хранения данных                                                                     | Диаграмма классов           |
| Расширяемость        | Разработчики | Как добавить новую команду и расширить приложение| Инструкция в архитектуре    |
| Пользовательский опыт| Пользователи| Правила ввода команд, форматы сообщений об ошибках| Примеры использования команд|

## 4. Архитектурные виды
### 4.1 Базовые компоненты системы
1. **CLI**\
   Основной процесс, который управляет жизненным циклом интерпретатора.
    * Управляет жизненным циклом интерпретатора.
    * Инициализирует систему (создает объект Environment).
    * Обрабатывает входную строку.
    * Передает строку в Parser.
    * Передает результат работы Parser в Pipeline.
    * Обновляет переменную окружения, отвечающую за код возврата.
2. **Parser** \
   Компонент для разбора входной строки.
    * Разбирает входную строку на токены.
    * Обрабатывает подстановку переменных окружения.
    * Проверяет синтаксис команд.
    * Создает объекты Command для каждой команды.
    * Возвращает список команд (List[Command]).
3. **Environment**\
   Компонент для работы с переменными.
    * Хранит переменные окружения.
    * Предоставляет методы для добавления, изменения и получения переменных.
4. **Pipeline**\
   Компонент для управления выполнением цепочки команд. Отвечает за:
    * Управляет выполнением цепочки команд.
    * Определяет потоки ввода и вывода для каждой команды.
    * Создает пул потоков для выполнения команд.
    * Ожидает завершения всех потоков.
5. **Executor**\
   Компонент для выполнения команд. Отвечает за:
    * Выполняет команды.
    * Проверяет, является ли команда встроенной.
    * Создает новые процессы для внешних команд.
    * Возвращает код возврата выполнения команды.
6. **Command**\
   Компонент, представляющий команду. Отвечает за:
    * Представляет команду.
    * Хранит имя команды, аргументы и стандартные потоки ввода/вывода.
    * Предоставляет методы для проверки аргументов и выполнения команды.

### 4.2 Вид "Функциональное поведение"
Соответствует Viewpoint "Функциональное поведение" для разработчиков
* Описание взаимодействия компонентов:
    * Пользователь вводит команду в CLI
    * CLI передаёт строку в Parser для обработки
    * Parser выполняет:
        * Разбиение на токены
        * Подстановку переменных из Environment
        * Создание объектов Command
    * Pipeline получает список Command и:
        * Для одиночных команд: напрямую передаёт в Executor
        * Для пайплайнов: организует потоки данных между командами
    * Executor выполняет команды, возвращая результат в CLI
    * CLI выводит результат пользователю и обновляет переменную ? (статус выполнения)

### 4.3 Вид "Хранение данных"
Соответствует Viewpoint "Функциональное поведение" для разработчиков
* Структуры данных:
    * Команды (Command):
        * Хранятся как объекты в памяти
        * Содержат: имя команды (строка), аргументы (список строк), потоки ввода и вывода и инкапсулирует валидацию встроенных команд
        * Жизненный цикл: от создания Parser'ом до завершения выполнения
    * Переменные окружения (Environment)
        * Формат хранения: Map<String, String> в памяти
        * Специальные переменные:
            * ? (код возврата последней команды)
        * Жизненный цикл: Существует в течение всей сессии CLI

### 4.4 Вид "Расширяемость системы"**
Соответствует Viewpoint "Расширяемость" для разработчиков
* Процесс добавления новой команды:
    * Добавление соответствующего обработчика в Executor.execute(Command), поскольку
    * Регистрация в Map внутри Command нового значения
    * Добавление в класс Command обработчика в метод checkNumberOfArguments

* Критические требования:
    * Все новые команды должны:
        * Возвращать корректный код статуса (0 - успех, >0 - ошибка)
        * Поддерживать перенаправление потоков (stdin/stdout)
        * Содержать валидацию аргументов
    * Пример:

  ```
  BUILTIN_COMMANDS_AND_ARG_COUNTS.put("count", 1);
  ```

### 4.5 Вид "Пользовательский опыт и обработка ошибок"
Соответствует Viewpoint "Пользовательский опыт" для пользователей и разработчиков
* Основные сценарии использования:
    * Сценарии использования:
  ```bash
    # Базовое выполнение команд
    > echo "Hello, $USER"  
    Hello, user
    ```
  *Компоненты:*

  CLI -> Parser (подстановка переменной) -> Executor -> CLI

    ```bash 
    # Пайплайн
    > cat text.in | grep "ERROR" | wc -l  
    42
    ```
  *Компоненты:*

  CLI -> Parser (разбиение на 3 команды) -> Pipeline (организация потоков) -> CLI

    ```bash
    # Работа с переменными
    > x=42; echo "x = $x"
    x = 42
    ```
  *Компоненты:*

  CLI -> Parser -> Pipeline -> Executor -> CLI

* Обработка ошибок:
    * Выводится понятное сообщение и ненулевой код возврата

### 4.6 Диаграммы архитектуры
**Диаграмма классов**:

![](images/class_diagram.png)
*Пояснение*: Отображает ключевые классы системы и их взаимосвязи

**Диаграмма компонентов**:
![](images/component_diagram.png)
*Пояснение*: Отображает взаимодействие компонентов

## 5. Взаимодействие компонентов
### 5.1 Принципы взаимодействия компонентов
* Пользователь вводит команду или пайплайн в терминале.
* CLI получает входную строку.
* CLI передает входную строку в Parser для дальнейшей обработки.
* Parser получает строку от CLI.
* Parser разбивает строку на токены с учетом кавычек и подстановок переменных.
* Parser обрабатывает подстановки переменных
    * Если в строке встречаются переменные, Parser запрашивает их значения у Environment.
    * Environment возвращает значение переменной.
    * Parser заменяет переменную на её значение в токенах.
* Parser удаляет кавычки и экранирует специальные символы:
    * Если токены содержат кавычки (одинарные или двойные), Parser удаляет их.
    * Специальные символы внутри двойных кавычек экранируются.
* Parser разбивает токены на команды:
    * Если в строке есть символ |, Parser разделяет токены на несколько команд.
* Для каждой команды Parser создает объект Command, который содержит:
    * Имя команды.
    * Аргументы команды (например, /home/user или user).
* Parser возвращает список объектов Command в CLI.
* CLI получает от Parser список команд (List[Command]).
* CLI передает этот список в Pipeline для выполнения.
* Pipeline получает список команд от CLI.
* Pipeline определяет, является ли список команд пайплайном (несколько команд, соединенных через |).
    * Если команда одна:
        * Pipeline передает команду в Executor для выполнения.
    * Если команды объединены в пайплайн:
        * Pipeline определяет потоки ввода и вывода для каждой команды.
        * Создает пул потоков для параллельного выполнения команд.
        * Передает каждую команду в Executor для выполнения.
    * Ожидает завершения всех потоков.
* Executor выполняет команды:
    * Executor получает команду от Pipeline.
    * Executor проверяет, является ли команда встроенной (isBuiltin).
        * Если команда встроенная (например, exit), выполняет ее и возвращает результат.
    * Если команда внешняя:
        * Создает новый процесс через ProcessBuilder.
        * Выполняет команду.
    * Возвращает код возврата выполнения команды в Pipeline.
* Pipeline возвращает результат в CLI:
    * Pipeline получает результат выполнения команды от Executor.
    * Pipeline возвращает результат выполнения (код возврата и вывод) в CLI.
* CLI обновляет переменные окружения и выводит результат:
    * CLI получает результат выполнения от Pipeline.
    * CLI обновляет переменную окружения, отвечающую за код возврата (например, переменную ?).
    * CLI выводит результат выполнения команды пользователю.
### 5.2 Обоснование решений
1. **Разделение ответственности**: Каждый компонент (Command, Environment, CLI, Parser, Pipeline, Executor) отвечает за одну задачу.
2. **Использование Pipeline для управления выполнением команд**. Pipeline поддерживает выполнение как одиночных команд, так и пайплайнов. Для пайплайнов используется пул потоков.
3. **Расширяемость системы**. Для добавления новой команды достаточно добавить соответствующий обработчик в Executor.execute(Command), поскольку поведения остальных частей не завязано на конкретную команду, а является общим для всех.
   Добавить в list/enum внутри Command новое значение.