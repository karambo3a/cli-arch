# Архитектура

## Основные компоненты системы
* CLI - основной процесс (main)
* Parser - парсер входной строки (команды)
* Environment - управляет переменными окружения
* Command - способ представления команд
* Pipeline - обрабатывает пайплайны
* Executor - отвечает за исполнение команд

## Используемые классы объектов
* Command:
	* name: str, 
    * enum/list: builtin_commands
    * args: List<Str> - список параметров команды 
    * stdin, stdout - не являются аргументами, задаются/изменяются отдельно в пайплайне или стандартные
	* constructor, isBuiltin, isExit, setStdin, setStdout
	* checkNumberOfArguments for each builtin command
* Environment:
	* vars: map[str, str]
	* getter, setter, contains(key) 
    * Cуществует отдельно созданная в конструкторе переменная "?", отвечающая за код возврата

## Описание методов остальных классов
* CLI
	1. Создание объекта окружения
	2. Обработка очередной пришедшей строки 
       * Вызов parserResult = Parser(string, env)
       * Вызов returnCode = Pipeline(parserResult)
    3. Обновление переменной окружения, отвечающей за код возврата
* Parser. Считается, что входная строка - команда (возможно пайплайн) или подстановка переменной
	1. Разбивает строку на токены, с учетом кавычек (объединяет в один токен)
	2. Определить если это подстановка переменной. Установить env.setVar
       * Проверить соответствует ли токен паттерну ```string=string``` без кавычек
	3. Если команда, выполнить подстановку окружения
       * Пройтись по всем токенам слева направо, найти которые соответствуют паттерну ```.*$string[$"' или конец-строки].*``` и не в двойных кавычках
       * Замена синтаксическая, подстановка одной строки вместо другой
       * Имя переменной определяется жадно, берется все до стоп символа ("'$) или окончания токена
       * Токен - это используемое наименования для обычной строки, просто показывающее, что строка была разделена по определенным правилам
    4. Подстановка/удаление кавычек. Для одинарных ничего делать не надо, 
       а все спец символы внутри двойных надо экранировать. 
       Удалить сами кавычки, сохранить в виде итоговой, готовой к print строке
	5. разбивает токены на List[List[str]] по "|"
	6. Создание Command как объекта (вызов конструктора от List[str]), для каждого элемента списка с прошлого шага
	7. Возвращает результат работы в формате List[Commands]
       * Результат разбора (parsing) представляется в формате List[Command], где List отвечает последовательности пайплайновых команд.
         Поскольку у нас нет вложенных команд, они хранятся индивидуально, в виде Command, а не AST
* Pipeline
	1. Обрабатывает только случай одной команды (НЕ цепочка с "|"). Выполняется единственный вызов команды ```Executor.execute(Command)```.
    2. В случае если ```Command.isExit()``` программа завершается, без вызова Executor (мы не поддерживаем коды возврата exit)
* Executor.execute(Command)
	* isBuiltin - специфичный для каждой программы. Executor выполняет переданную команду
       * Команда exit имеет интерфейс Command, но ее исполнение ничего не делает, только возвращает код 0
	* !isBuiltin - создание нового процесса (ProcessBuilder)
    * Возвращаемое значение - код возврата выполнения команды, соответствует стандартным спецификациям shell 
      (0 - успешно, >0 - ошибка)

## Добавление новых команд
Для добавления новой команды достаточно добавить соответствующий обработчик в Executor.execute(Command), поскольку 
поведения остальных частей не завязано на конкретную команду, а является общим для всех. 
* Добавить в list/enum внутри Command новое значение
* Добавить в Executor метод для обработки новой команды

## Class diagram

![](images/class_diagram.jpg)

## Component diagram

![](images/component_diagram.jpg)
