# Архитектура

## Основные компоненты системы
* CLI - основной процесс (main)
* Parser - парсер входной строки (команды)
* Environment - управляет переменными окружения
* Command - способ представления команд
* Pipeline - обрабатывает пайплайны
* Executor - отвечает за исполнение команд

## Используемые классы объектов
* Command:
    * name: str,
    * enum/list: builtin_commands
    * args: List<Str> - список параметров команды
    * stdin, stdout - не являются аргументами, задаются/изменяются отдельно в пайплайне или стандартные
    * constructor, setStdin, setStdout, getArgs, getName, getStdin, getStdout
* Environment:
    * vars: map[str, str]
    * getter, setter, contains(key)
    * Cуществует отдельно созданная в конструкторе переменная "?", отвечающая за код возврата
* GrepArgs: (package private)
    * Класс, предназначенный для парсинга аргументов команды grep. Использует библиотеку JCommand
    * wholeWorld, caseInsensitive: boolean
    * additionalLines: int
    * positionalParams: List<String>. Считается, что pattern всегда идет раньше названия файла
    * getAdditionalLines, getPattern (c учетом wholeWorld, caseInsensitive), getFileNames

## Описание методов остальных классов
* CLI
    1. Создание объекта окружения
    2. Обработка очередной пришедшей строки
        * Вызов parserResult = Parser(string, env)
        * Вызов returnCode = Pipeline(parserResult)
    3. Обновление переменной окружения, отвечающей за код возврата
* Parser. Считается, что входная строка - команда (возможно пайплайн) или подстановка переменной
    1. Разбивает строку на токены, с учетом кавычек (объединяет в один токен)
    2. Определить если это подстановка переменной. Установить env.setVar
        * Проверить соответствует ли токен паттерну ```string=string``` без кавычек
    3. Если команда, выполнить подстановку окружения
        * Пройтись по всем токенам слева направо, найти которые соответствуют паттерну ```.*$string[$"' или конец-строки].*``` и не в двойных кавычках
        * Замена синтаксическая, подстановка одной строки вместо другой
        * Имя переменной определяется жадно, берется все до стоп символа ("'$) или окончания токена
        * Токен - это используемое наименования для обычной строки, просто показывающее, что строка была разделена по определенным правилам
    4. Подстановка/удаление кавычек. Для одинарных ничего делать не надо,
       а все спец символы внутри двойных надо экранировать.
       Удалить сами кавычки, сохранить в виде итоговой, готовой к print строке
    5. разбивает токены на List[List[str]] по "|"
    6. Создание Command как объекта (вызов конструктора от List[str]), для каждого элемента списка с прошлого шага
    7. Возвращает результат работы в формате List[Commands]
        * Результат разбора (parsing) представляется в формате List[Command], где List отвечает последовательности пайплайновых команд.
          Поскольку у нас нет вложенных команд, они хранятся индивидуально, в виде Command, а не AST
* Pipeline
    1. Определяется, является ли переданная цепочка команд пайплайна или индивидуальной
        * Если команда одна (НЕ цепочка с "|"), то просто выполняется единственный вызов команды ```Executor.execute(Command)```
        * В случае если ```Command.isExit()``` программа завершается, без вызова Executor (мы не поддерживаем коды возврата exit, всегда 0)
        * Возвращаемое значение совпадает с ```Executor.execute(Command)```
    2. Случай паплайна.
    3. Для каждой команды определяет поток ввода и вывода, например через PipedInputStream
    4. Создается пулл потоков.
    5. Исполняет каждую команды в отдельном потоке (вызов Executor.execute(Command))
    6. дожидается завершения всех потоков
    7. Возвращаемое значение совпадает с кодом возврата последней выполненной команды
* Executor.execute(Command)
    * isBuiltin - специфичный для каждой программы. Executor выполняет переданную команду
        * Команда exit имеет интерфейс Command, но ее исполнение ничего не делает, только возвращает код 0
    * !isBuiltin - создание нового процесса (ProcessBuilder)
    * Возвращаемое значение - код возврата выполнения команды, соответствует стандартным спецификациям shell
      (0 - успешно, >0 - ошибка)

## Добавление новых команд
Для добавления новой команды надо
* добавить соответствующий обработчик в Executor
* Добавить в map внутри Executor новое значение - имя команды и соответствующий обработчик

## Class diagram

![](images/class_diagram.png)

## Component diagram

![](images/component_diagram.png)

### Разбор аргументов командной строки

Для реализации команды `grep` мы рассмотрели следующие библиотеки и фреймворки для разбора параметров командной строки:

### Apache Commons CLI

**Преимущества**:

1. Низкий порог входа благодаря подробной документации и множеству примеров
2. Поддержка как коротких, так и длинных флагов
3. Обработка позиционных аргументов
4. Встроенная поддержка сообщений справки

**Недостатки**:

1. Отсутствие поддержки аннотаций, что приводит к большему количеству шаблонного кода
2. Нет поддержки подкоманд
3. Все значения возвращаются как строки, требуется ручной парсинг
4. Ручная валидация входных данных

**Лучше всего подходит для**: Небольших CLI-приложений, где важна простота

### JCommander

**Преимущества**:

1. Конфигурация на основе аннотаций
2. Поддержка вложенных команд и подкоманд
3. Встроенная валидация
4. Возможность указания значений по умолчанию
5. Хорошая документация и активное сообщество

**Недостатки**:

1. Отсутствие встроенной поддержки цветного вывода
2. Нет автодополнения команд
3. Требует Java 8 или выше

**Лучше всего подходит для**: CLI-приложений средней сложности, которым нужно больше возможностей, чем Apache Commons CLI

### Picocli

**Преимущества**:

1. Полноценная поддержка автодополнения
2. Встроенный цветной вывод
3. Поддержка сообщений справки в виде таблиц
4. Валидация на основе аннотаций
5. Автоматическое преобразование типов
6. Отличная поддержка подкоманд

**Недостатки**:

1. Более сложная настройка
2. Больший размер зависимостей

**Лучше всего подходит для**: Профессиональных CLI-приложений с богатым функционалом

### Airline

**Преимущества**:

1. Интегрированная система валидации
2. Поддержка неограниченной вложенности команд
3. Гибкое определение команд (аннотации или программно)

**Недостатки**:

1. Нет встроенного автодополнения
2. Отсутствие поддержки цветного вывода
3. Избыточная сложность для небольших утилит
4. Меньшая поддержка сообщества

**Лучше всего подходит для**: Сложных CLI-приложений с глубокой иерархией команд

### Наше решение

Мы выбрали **JCommander**, потому что:

- Он предоставляет больше возможностей, чем Apache Commons CLI
- Поддержка аннотаций повышает эффективность разработки
- Дополнительные возможности Picocli и Airline были бы избыточны для нашего проекта